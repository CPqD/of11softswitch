lib/dhcp.c:        free(msg->data);
lib/dhcp.c:    size_t needed = msg->data_used + n;
lib/dhcp.c:    if (needed > msg->data_allocated) {
lib/dhcp.c:        uint8_t *old_data = msg->data;
lib/dhcp.c:        msg->data_allocated = MAX(needed * 2, 64);
lib/dhcp.c:        msg->data = xmalloc(msg->data_allocated);
lib/dhcp.c:    uint8_t *p = &msg->data[msg->data_used];
lib/dhcp.c:    msg->data_used += n;
lib/dhcp.c:    msg->data_used = 0;
lib/dhcp.c:        struct dhcp_option *opt = &msg->options[code];
lib/dhcp.c:            assert(msg->data_used + opt->n <= msg->data_allocated);
lib/dhcp.c:    opt = &msg->options[code];
lib/dhcp.c:        if (&msg->data[msg->data_used - opt->n] != opt->data) {
lib/dhcp.c:    const struct dhcp_option *opt = &msg->options[code];
lib/dhcp.c:    const struct dhcp_option *opt = &msg->options[code];
lib/dhcp.c:                  (msg->op == DHCP_BOOTREQUEST ? "request"
lib/dhcp.c:                   : msg->op == DHCP_BOOTREPLY ? "reply"
lib/dhcp.c:    ds_put_format(ds, "%ctype=%s", separator, dhcp_type_name(msg->type));
lib/dhcp.c:    ds_put_format(ds, "%cxid=0x%08"PRIx32, separator, msg->xid);
lib/dhcp.c:    put_duration(ds, msg->secs);
lib/dhcp.c:    if (msg->flags) {
lib/dhcp.c:        if (msg->flags & DHCP_FLAGS_BROADCAST) {
lib/dhcp.c:        if (msg->flags & DHCP_FLAGS_MBZ) {
lib/dhcp.c:            ds_put_format(ds, "[0x%04"PRIx16"]", msg->flags & DHCP_FLAGS_MBZ);
lib/dhcp.c:    if (msg->ciaddr) {
lib/dhcp.c:        ds_put_format(ds, "%cciaddr="IP_FMT, separator, IP_ARGS(&msg->ciaddr));
lib/dhcp.c:    if (msg->yiaddr) {
lib/dhcp.c:        ds_put_format(ds, "%cyiaddr="IP_FMT, separator, IP_ARGS(&msg->yiaddr));
lib/dhcp.c:    if (msg->siaddr) {
lib/dhcp.c:        ds_put_format(ds, "%csiaddr="IP_FMT, separator, IP_ARGS(&msg->siaddr));
lib/dhcp.c:    if (msg->giaddr) {
lib/dhcp.c:        ds_put_format(ds, "%cgiaddr="IP_FMT, separator, IP_ARGS(&msg->giaddr));
lib/dhcp.c:                  separator, ETH_ADDR_ARGS(msg->chaddr));
lib/dhcp.c:        const struct dhcp_option *opt = &msg->options[code];
lib/dhcp.c:        struct dhcp_option *opt = &msg->options[code];
lib/dhcp.c:    msg->op = dhcp->op;
lib/dhcp.c:    msg->xid = ntohl(dhcp->xid);
lib/dhcp.c:    msg->secs = ntohs(dhcp->secs);
lib/dhcp.c:    msg->flags = ntohs(dhcp->flags);
lib/dhcp.c:    msg->ciaddr = dhcp->ciaddr;
lib/dhcp.c:    msg->yiaddr = dhcp->yiaddr;
lib/dhcp.c:    msg->siaddr = dhcp->siaddr;
lib/dhcp.c:    msg->giaddr = dhcp->giaddr;
lib/dhcp.c:    memcpy(msg->chaddr, dhcp->chaddr, ETH_ADDR_LEN);
lib/dhcp.c:                      msg->options[DHCP_CODE_VENDOR_SPECIFIC].data,
lib/dhcp.c:                      msg->options[DHCP_CODE_VENDOR_SPECIFIC].n,
lib/dhcp.c:    msg->type = type;
lib/dhcp.c:    dhcp.op = msg->op;
lib/dhcp.c:    dhcp.xid = htonl(msg->xid);
lib/dhcp.c:    dhcp.secs = htons(msg->secs);
lib/dhcp.c:    dhcp.flags = htons(msg->flags);
lib/dhcp.c:    dhcp.ciaddr = msg->ciaddr;
lib/dhcp.c:    dhcp.yiaddr = msg->yiaddr;
lib/dhcp.c:    dhcp.siaddr = msg->siaddr;
lib/dhcp.c:    dhcp.giaddr = msg->giaddr;
lib/dhcp.c:    memcpy(dhcp.chaddr, msg->chaddr, ETH_ADDR_LEN);
lib/dhcp.c:    if (msg->type) {
lib/dhcp.c:        uint8_t type = msg->type;
lib/dhcp.c:        const struct dhcp_option *option = &msg->options[i];
lib/dhcp.c:        const struct dhcp_option *option = &msg->options[i];
lib/ofpstat.c:	uint16_t errtype = ntohs(errmsg->type);
lib/ofpstat.c:	uint16_t errcode = ntohs(errmsg->code);
lib/ofpstat.c:	uint16_t flowmodops = ntohs(flowmodmsg->command);
lib/ofp.c:    error = check_message_type(msg->type, type);
lib/ofp.c:    got_size = ntohs(msg->length);
lib/ofp.c:    error = check_message_type(msg->type, type);
lib/ofp.c:    got_size = ntohs(msg->length);
lib/dhcp-client.c:    msg->ciaddr = dhclient_get_ip(cli);
lib/dhcp-client.c:        if (msg->type > 31 || !((1u << msg->type) & msgs)) {
lib/dhcp-client.c:                        dhcp_type_name(msg->type), state_name(cli->state),
lib/dhcp-client.c:        } else if (msg->xid != cli->xid) {
lib/dhcp-client.c:                        dhcp_type_name(msg->type), msg->xid,
lib/dhcp-client.c:        VLOG_WARN_RL(LOG_MODULE, &rl, "%s lacks lease time: %s", dhcp_type_name(msg->type),
lib/dhcp-client.c:        VLOG_WARN_RL(LOG_MODULE, &rl, "%s lacks netmask: %s", dhcp_type_name(msg->type),
lib/dhcp-client.c:                     dhcp_type_name(msg->type), lease,
lib/dhcp-client.c:    msg->op = DHCP_BOOTREQUEST;
lib/dhcp-client.c:    msg->xid = cli->xid;
lib/dhcp-client.c:    msg->secs = cli->secs;
lib/dhcp-client.c:    msg->type = type;
lib/dhcp-client.c:    memcpy(msg->chaddr, netdev_get_etheraddr(cli->netdev), ETH_ADDR_LEN);
lib/dhcp-client.c:                VLOG_INFO_RL(LOG_MODULE, &rl, "received %s", dhcp_type_name(msg->type));
lib/dhcp-client.c:            VLOG_INFO(LOG_MODULE, "sending %s", dhcp_type_name(msg->type));
lib/vlog-socket.c:        if (cmsg->cmsg_level == SOL_SOCKET
lib/vlog-socket.c:            && cmsg->cmsg_type == SCM_CREDENTIALS) {
lib/vlog-socket.c:        } else if (cmsg->cmsg_level == SOL_SOCKET
lib/vlog-socket.c:                   && cmsg->cmsg_type == SCM_RIGHTS) {
lib/vlog-socket.c:            size_t n_fds = (cmsg->cmsg_len - CMSG_LEN(0)) / sizeof *fds;
lib/vlog-socket.c:    cmsg->cmsg_level = SOL_SOCKET;
lib/vlog-socket.c:    cmsg->cmsg_type = SCM_CREDENTIALS;
lib/vlog-socket.c:    cmsg->cmsg_len = CMSG_LEN(sizeof cred);
lib/vlog-socket.c:    msg.msg_controllen = cmsg->cmsg_len;
lib/netlink.c: * 'sock'.  nlmsg_len in 'msg' will be finalized to match msg->size before the
lib/netlink.c:    nl_msg_nlmsghdr(msg)->nlmsg_len = msg->size;
lib/netlink.c:        retval = send(sock->fd, msg->data, msg->size, wait ? 0 : MSG_DONTWAIT);
lib/netlink.c:    log_nlmsg(__func__, error, msg->data, msg->size);
lib/netlink.c:                        msg->size, NLMSG_HDRLEN + sizeof *err);
lib/netlink.c:    assert(msg->size == 0);
lib/netlink.c:    assert(msg->size == NLMSG_HDRLEN);
lib/netlink.c: * 'nested_msg' is finalized to match 'nested_msg->size'. */
lib/netlink.c:    nl_msg_nlmsghdr(nested_msg)->nlmsg_len = nested_msg->size;
lib/netlink.c:    nl_msg_put_unspec(msg, type, nested_msg->data, nested_msg->size);
lib/netlink.c:        size_t offset = (char*)p - (char*)msg->data;
oflib/ofl-messages-unpack.c:            if (exp == NULL || exp->msg == NULL || exp->msg->unpack == NULL) {
oflib/ofl-messages-unpack.c:                error = exp->msg->unpack(oh, &len, (struct ofl_msg_experimenter **)msg);
oflib/ofl-messages-pack.c:    *buf_len = sizeof(struct ofp_error_msg) + msg->data_length;
oflib/ofl-messages-pack.c:    err->type = htons(msg->type);
oflib/ofl-messages-pack.c:    err->code = htons(msg->code);
oflib/ofl-messages-pack.c:    memcpy(err->data, msg->data, msg->data_length);
oflib/ofl-messages-pack.c:    *buf_len = sizeof(struct ofp_header) + msg->data_length;
oflib/ofl-messages-pack.c:    if (msg->data_length > 0) {
oflib/ofl-messages-pack.c:        memcpy(data, msg->data, msg->data_length);
oflib/ofl-messages-pack.c:    *buf_len = sizeof(struct ofp_switch_features) + msg->ports_num * sizeof(struct ofp_port);
oflib/ofl-messages-pack.c:    features->datapath_id  = hton64(msg->datapath_id);
oflib/ofl-messages-pack.c:    features->n_buffers    = htonl( msg->n_buffers);
oflib/ofl-messages-pack.c:    features->n_tables     =        msg->n_tables;
oflib/ofl-messages-pack.c:    features->capabilities = htonl( msg->capabilities);
oflib/ofl-messages-pack.c:    for (i=0; i<msg->ports_num; i++) {
oflib/ofl-messages-pack.c:        ptr += ofl_structs_port_pack(msg->ports[i], (struct ofp_port *)ptr);
oflib/ofl-messages-pack.c:    config->flags         = htons(msg->config->flags);
oflib/ofl-messages-pack.c:    config->miss_send_len = htons(msg->config->miss_send_len);
oflib/ofl-messages-pack.c:    config->miss_send_len = htons(msg->config->miss_send_len);
oflib/ofl-messages-pack.c:    config->flags = htons(msg->config->flags);
oflib/ofl-messages-pack.c:    *buf_len = sizeof(struct ofp_packet_in) + msg->data_length;
oflib/ofl-messages-pack.c:    packet_in->buffer_id   = htonl(msg->buffer_id);
oflib/ofl-messages-pack.c:    packet_in->in_port     = htonl(msg->in_port);
oflib/ofl-messages-pack.c:    packet_in->in_phy_port = htonl(msg->in_phy_port);
oflib/ofl-messages-pack.c:    packet_in->total_len   = htons(msg->total_len);
oflib/ofl-messages-pack.c:    packet_in->reason      =       msg->reason;
oflib/ofl-messages-pack.c:    packet_in->table_id    =       msg->table_id;
oflib/ofl-messages-pack.c:    if (msg->data_length > 0) {
oflib/ofl-messages-pack.c:        memcpy(packet_in->data, msg->data, msg->data_length);
oflib/ofl-messages-pack.c:    ofr->cookie        = hton64(msg->stats->cookie);
oflib/ofl-messages-pack.c:    ofr->priority      = hton64(msg->stats->priority);
oflib/ofl-messages-pack.c:    ofr->reason        =        msg->reason;
oflib/ofl-messages-pack.c:    ofr->table_id      =        msg->stats->table_id;
oflib/ofl-messages-pack.c:    ofr->duration_sec  = htonl( msg->stats->duration_sec);
oflib/ofl-messages-pack.c:    ofr->duration_nsec = htonl( msg->stats->duration_nsec);
oflib/ofl-messages-pack.c:    ofr->idle_timeout  = htons( msg->stats->idle_timeout);
oflib/ofl-messages-pack.c:    ofr->packet_count  = hton64(msg->stats->packet_count);
oflib/ofl-messages-pack.c:    ofr->byte_count    = hton64(msg->stats->byte_count);
oflib/ofl-messages-pack.c:    ofl_structs_match_pack(msg->stats->match, &(ofr->match), exp);
oflib/ofl-messages-pack.c:    status->reason = msg->reason;
oflib/ofl-messages-pack.c:    ofl_structs_port_pack(msg->desc, &(status->desc));
oflib/ofl-messages-pack.c:    act_len = ofl_actions_ofp_total_len(msg->actions, msg->actions_num, exp);
oflib/ofl-messages-pack.c:    *buf_len = sizeof(struct ofp_packet_out) + act_len + msg->data_length;
oflib/ofl-messages-pack.c:    packet_out->buffer_id   = htonl(msg->buffer_id);
oflib/ofl-messages-pack.c:    packet_out->in_port     = htonl(msg->in_port);
oflib/ofl-messages-pack.c:    for (i=0; i<msg->actions_num; i++) {
oflib/ofl-messages-pack.c:        ptr += ofl_actions_pack(msg->actions[i], (struct ofp_action_header *)ptr, exp);
oflib/ofl-messages-pack.c:    if (msg->data_length > 0) {
oflib/ofl-messages-pack.c:        memcpy(ptr, msg->data, msg->data_length);
oflib/ofl-messages-pack.c:    *buf_len = sizeof(struct ofp_flow_mod) + ofl_structs_instructions_ofp_total_len(msg->instructions, msg->instructions_num, exp);;
oflib/ofl-messages-pack.c:    flow_mod->cookie       = hton64(msg->cookie);
oflib/ofl-messages-pack.c:    flow_mod->cookie_mask  = hton64(msg->cookie_mask);
oflib/ofl-messages-pack.c:    flow_mod->table_id     =        msg->table_id;
oflib/ofl-messages-pack.c:    flow_mod->command      =        msg->command;
oflib/ofl-messages-pack.c:    flow_mod->idle_timeout = htons( msg->idle_timeout);
oflib/ofl-messages-pack.c:    flow_mod->hard_timeout = htons( msg->hard_timeout);
oflib/ofl-messages-pack.c:    flow_mod->priority     = htons( msg->priority);
oflib/ofl-messages-pack.c:    flow_mod->buffer_id    = htonl( msg->buffer_id);
oflib/ofl-messages-pack.c:    flow_mod->out_port     = htonl( msg->out_port);
oflib/ofl-messages-pack.c:    flow_mod->out_group    = htonl( msg->out_group);
oflib/ofl-messages-pack.c:    flow_mod->flags        = htons( msg->flags);
oflib/ofl-messages-pack.c:    ofl_structs_match_pack(msg->match, &(flow_mod->match), exp);
oflib/ofl-messages-pack.c:    for (i=0; i<msg->instructions_num; i++) {
oflib/ofl-messages-pack.c:        ptr += ofl_structs_instructions_pack(msg->instructions[i], (struct ofp_instruction *)ptr, exp);
oflib/ofl-messages-pack.c:    *buf_len = sizeof(struct ofp_group_mod) + ofl_structs_buckets_ofp_total_len(msg->buckets, msg->buckets_num, exp);;
oflib/ofl-messages-pack.c:    group_mod->command  = htons(msg->command);
oflib/ofl-messages-pack.c:    group_mod->type     =       msg->type;
oflib/ofl-messages-pack.c:    group_mod->group_id = htonl(msg->group_id);
oflib/ofl-messages-pack.c:    for (i=0; i<msg->buckets_num; i++) {
oflib/ofl-messages-pack.c:        ptr += ofl_structs_bucket_pack(msg->buckets[i], (struct ofp_bucket *)ptr, exp);
oflib/ofl-messages-pack.c:    port_mod->port_no   = htonl(msg->port_no);
oflib/ofl-messages-pack.c:    memcpy(&(port_mod->hw_addr), &(msg->hw_addr), OFP_ETH_ALEN);
oflib/ofl-messages-pack.c:    port_mod->config    = htonl(msg->config);
oflib/ofl-messages-pack.c:    port_mod->mask      = htonl(msg->mask);
oflib/ofl-messages-pack.c:    port_mod->advertise = htonl(msg->advertise);
oflib/ofl-messages-pack.c:    table_mod->table_id =       msg->table_id;
oflib/ofl-messages-pack.c:    table_mod->config   = htonl(msg->config);
oflib/ofl-messages-pack.c:    stats->table_id    =        msg->table_id;
oflib/ofl-messages-pack.c:    stats->out_port    = htonl( msg->out_port);
oflib/ofl-messages-pack.c:    stats->out_group   = htonl( msg->out_group);
oflib/ofl-messages-pack.c:    stats->cookie      = hton64(msg->cookie);
oflib/ofl-messages-pack.c:    stats->cookie_mask = hton64(msg->cookie_mask);
oflib/ofl-messages-pack.c:    ofl_structs_match_pack(msg->match, &(stats->match), exp);
oflib/ofl-messages-pack.c:    stats->port_no = htonl(msg->port_no);
oflib/ofl-messages-pack.c:    stats->port_no = htonl(msg->port_no);
oflib/ofl-messages-pack.c:    stats->queue_id = htonl(msg->queue_id);
oflib/ofl-messages-pack.c:    stats->group_id = htonl(msg->group_id);
oflib/ofl-messages-pack.c:    switch (msg->type) {
oflib/ofl-messages-pack.c:    req->type  = htons(msg->type);
oflib/ofl-messages-pack.c:    req->flags = htons(msg->flags);
oflib/ofl-messages-pack.c:    memcpy(stats->mfr_desc,   msg->mfr_desc, DESC_STR_LEN);
oflib/ofl-messages-pack.c:    memcpy(stats->hw_desc,    msg->hw_desc, DESC_STR_LEN);
oflib/ofl-messages-pack.c:    memcpy(stats->sw_desc,    msg->sw_desc, DESC_STR_LEN);
oflib/ofl-messages-pack.c:    memcpy(stats->serial_num, msg->serial_num, SERIAL_NUM_LEN);
oflib/ofl-messages-pack.c:    memcpy(stats->dp_desc,    msg->dp_desc, DESC_STR_LEN);
oflib/ofl-messages-pack.c:    *buf_len = sizeof(struct ofp_stats_reply) + ofl_structs_flow_stats_ofp_total_len(msg->stats, msg->stats_num, exp);
oflib/ofl-messages-pack.c:    for (i=0; i<msg->stats_num; i++) {
oflib/ofl-messages-pack.c:        data += ofl_structs_flow_stats_pack(msg->stats[i], (struct ofp_flow_stats *)data, exp);
oflib/ofl-messages-pack.c:    stats->packet_count = hton64(msg->packet_count);
oflib/ofl-messages-pack.c:    stats->byte_count   = hton64(msg->byte_count);
oflib/ofl-messages-pack.c:    stats->flow_count   = htonl( msg->flow_count);
oflib/ofl-messages-pack.c:    *buf_len = sizeof(struct ofp_stats_reply) + msg->stats_num * sizeof(struct ofp_table_stats);
oflib/ofl-messages-pack.c:    for (i=0; i<msg->stats_num; i++) {
oflib/ofl-messages-pack.c:        data += ofl_structs_table_stats_pack(msg->stats[i], (struct ofp_table_stats *)data);
oflib/ofl-messages-pack.c:    *buf_len = sizeof(struct ofp_stats_reply) + msg->stats_num * sizeof(struct ofp_port_stats);
oflib/ofl-messages-pack.c:    for (i=0; i<msg->stats_num; i++) {
oflib/ofl-messages-pack.c:        data += ofl_structs_port_stats_pack(msg->stats[i], (struct ofp_port_stats *)data);
oflib/ofl-messages-pack.c:    *buf_len = sizeof(struct ofp_stats_reply) + msg->stats_num * sizeof(struct ofp_queue_stats);
oflib/ofl-messages-pack.c:    for (i=0; i<msg->stats_num; i++) {
oflib/ofl-messages-pack.c:        data += ofl_structs_queue_stats_pack(msg->stats[i], (struct ofp_queue_stats *)data);
oflib/ofl-messages-pack.c:    *buf_len = sizeof(struct ofp_stats_reply) + ofl_structs_group_stats_ofp_total_len(msg->stats, msg->stats_num);
oflib/ofl-messages-pack.c:    for (i=0; i<msg->stats_num; i++) {
oflib/ofl-messages-pack.c:        data += ofl_structs_group_stats_pack(msg->stats[i], (struct ofp_group_stats *)data);
oflib/ofl-messages-pack.c:    *buf_len = sizeof(struct ofp_stats_reply) + ofl_structs_group_desc_stats_ofp_total_len(msg->stats, msg->stats_num, exp);
oflib/ofl-messages-pack.c:    for (i=0; i<msg->stats_num; i++) {
oflib/ofl-messages-pack.c:        data += ofl_structs_group_desc_stats_pack(msg->stats[i], (struct ofp_group_desc_stats *)data, exp);
oflib/ofl-messages-pack.c:    switch (msg->type) {
oflib/ofl-messages-pack.c:    resp->type  = htons(msg->type);
oflib/ofl-messages-pack.c:    resp->flags = htons(msg->flags);
oflib/ofl-messages-pack.c:    req->port = htonl(msg->port);
oflib/ofl-messages-pack.c:    *buf_len = sizeof(struct ofp_queue_get_config_reply) + ofl_structs_packet_queue_ofp_total_len(msg->queues, msg->queues_num);
oflib/ofl-messages-pack.c:    resp->port = htonl(msg->port);
oflib/ofl-messages-pack.c:    for (i=0; i<msg->queues_num; i++) {
oflib/ofl-messages-pack.c:        data += ofl_structs_packet_queue_pack(msg->queues[i], (struct ofp_packet_queue *)data);
oflib/ofl-messages-pack.c:    switch (msg->type) {
oflib/ofl-messages-pack.c:            if (exp == NULL || exp->msg == NULL || exp->msg->pack == NULL) {
oflib/ofl-messages-pack.c:                error = exp->msg->pack((struct ofl_msg_experimenter *)msg, buf, buf_len);
oflib/ofl-messages-pack.c:    oh->type    =        msg->type;
oflib/ofl-messages-print.c:    ofl_error_type_print(stream, msg->type);
oflib/ofl-messages-print.c:    ofl_error_code_print(stream, msg->type, msg->code);
oflib/ofl-messages-print.c:    fprintf(stream, "\", dlen=\"%zu\"}", msg->data_length);
oflib/ofl-messages-print.c:    fprintf(stream, "{dlen=\"%zu\"}", msg->data_length);
oflib/ofl-messages-print.c:    fprintf(stream, "{id=\"0x%"PRIx32"\"}", msg->experimenter_id);
oflib/ofl-messages-print.c:                  msg->datapath_id, msg->n_buffers, msg->n_tables,
oflib/ofl-messages-print.c:                  msg->capabilities);
oflib/ofl-messages-print.c:    for (i=0; i < msg->ports_num; i++) {
oflib/ofl-messages-print.c:        ofl_structs_port_print(stream, msg->ports[i]);
oflib/ofl-messages-print.c:        if (i < msg->ports_num - 1) { fprintf(stream, ", "); }
oflib/ofl-messages-print.c:    ofl_structs_config_print(stream, msg->config);
oflib/ofl-messages-print.c:    ofl_structs_config_print(stream, msg->config);
oflib/ofl-messages-print.c:    ofl_buffer_print(stream, msg->buffer_id);
oflib/ofl-messages-print.c:    ofl_port_print(stream, msg->in_port);
oflib/ofl-messages-print.c:    ofl_port_print(stream, msg->in_phy_port);
oflib/ofl-messages-print.c:    fprintf(stream, "\", tlen=\"%u\", reas=\"", msg->total_len);
oflib/ofl-messages-print.c:    ofl_packet_in_reason_print(stream, msg->reason);
oflib/ofl-messages-print.c:    ofl_table_print(stream, msg->table_id);
oflib/ofl-messages-print.c:    fprintf(stream, "\", dlen=\"%zu\"}", msg->data_length);
oflib/ofl-messages-print.c:    ofl_flow_removed_reason_print(stream, msg->reason);
oflib/ofl-messages-print.c:    ofl_structs_flow_stats_print(stream, msg->stats, exp);
oflib/ofl-messages-print.c:    ofl_port_status_reason_print(stream, msg->reason);
oflib/ofl-messages-print.c:    ofl_structs_port_print(stream, msg->desc);
oflib/ofl-messages-print.c:    ofl_buffer_print(stream, msg->buffer_id);
oflib/ofl-messages-print.c:    ofl_port_print(stream, msg->in_port);
oflib/ofl-messages-print.c:    for (i=0; i<msg->actions_num; i++) {
oflib/ofl-messages-print.c:        ofl_action_print(stream, msg->actions[i], exp);
oflib/ofl-messages-print.c:        if (i < msg->actions_num - 1) { fprintf(stream, ", "); }
oflib/ofl-messages-print.c:    ofl_table_print(stream, msg->table_id);
oflib/ofl-messages-print.c:    ofl_flow_mod_command_print(stream, msg->command);
oflib/ofl-messages-print.c:                  msg->cookie, msg->cookie_mask,
oflib/ofl-messages-print.c:                  msg->idle_timeout, msg->hard_timeout, msg->priority);
oflib/ofl-messages-print.c:    ofl_buffer_print(stream, msg->buffer_id);
oflib/ofl-messages-print.c:    ofl_port_print(stream, msg->out_port);
oflib/ofl-messages-print.c:    ofl_group_print(stream, msg->out_group);
oflib/ofl-messages-print.c:    fprintf(stream, "\", flags=\"0x%"PRIx16"\", match=",msg->flags);
oflib/ofl-messages-print.c:    ofl_structs_match_print(stream, msg->match, exp);
oflib/ofl-messages-print.c:    for(i=0; i<msg->instructions_num; i++) {
oflib/ofl-messages-print.c:        ofl_structs_instruction_print(stream, msg->instructions[i], exp);
oflib/ofl-messages-print.c:        if (i < msg->instructions_num - 1) { fprintf(stream, ", "); }
oflib/ofl-messages-print.c:    ofl_group_print(stream, msg->group_id);
oflib/ofl-messages-print.c:    ofl_group_mod_command_print(stream, msg->command);
oflib/ofl-messages-print.c:    ofl_group_type_print(stream, msg->type);
oflib/ofl-messages-print.c:    for (i=0; i<msg->buckets_num; i++) {
oflib/ofl-messages-print.c:        ofl_structs_bucket_print(stream, msg->buckets[i], exp);
oflib/ofl-messages-print.c:        if (i < msg->buckets_num - 1) { fprintf(stream, ", "); }
oflib/ofl-messages-print.c:    ofl_port_print(stream, msg->port_no);
oflib/ofl-messages-print.c:                  ETH_ADDR_ARGS(msg->hw_addr), msg->config, msg->mask, msg->advertise);
oflib/ofl-messages-print.c:    ofl_table_print(stream, msg->table_id);
oflib/ofl-messages-print.c:    fprintf(stream, "\", config=\"0x%08"PRIx32"\"}", msg->config);
oflib/ofl-messages-print.c:    ofl_table_print(stream, msg->table_id);
oflib/ofl-messages-print.c:    ofl_port_print(stream, msg->out_port);
oflib/ofl-messages-print.c:    ofl_group_print(stream, msg->out_group);
oflib/ofl-messages-print.c:                  msg->cookie, msg->cookie_mask);
oflib/ofl-messages-print.c:    ofl_structs_match_print(stream, msg->match, exp);
oflib/ofl-messages-print.c:    ofl_port_print(stream, msg->port_no);
oflib/ofl-messages-print.c:    ofl_port_print(stream, msg->port_no);
oflib/ofl-messages-print.c:    ofl_queue_print(stream, msg->queue_id);
oflib/ofl-messages-print.c:    ofl_group_print(stream, msg->group_id);
oflib/ofl-messages-print.c:    ofl_group_print(stream, msg->experimenter_id);
oflib/ofl-messages-print.c:    if (msg->type == OFPST_EXPERIMENTER) {
oflib/ofl-messages-print.c:    ofl_stats_type_print(stream, msg->type);
oflib/ofl-messages-print.c:    fprintf(stream, "\", flags=\"0x%"PRIx32"\"", msg->flags);
oflib/ofl-messages-print.c:    switch (msg->type) {
oflib/ofl-messages-print.c:                  msg->mfr_desc, msg->hw_desc, msg->sw_desc, msg->serial_num, msg->dp_desc);
oflib/ofl-messages-print.c:    for (i=0; i<msg->stats_num; i++) {
oflib/ofl-messages-print.c:        ofl_structs_flow_stats_print(stream, msg->stats[i], exp);
oflib/ofl-messages-print.c:        if (i < msg->stats_num - 1) { fprintf(stream, ", "); };
oflib/ofl-messages-print.c:                  msg->packet_count, msg->byte_count, msg->flow_count);
oflib/ofl-messages-print.c:    for (i=0; i<msg->stats_num; i++) {
oflib/ofl-messages-print.c:        ofl_structs_table_stats_print(stream, msg->stats[i]);
oflib/ofl-messages-print.c:        if (i < msg->stats_num - 1) { fprintf(stream, ", "); };
oflib/ofl-messages-print.c:    for (i=0; i<msg->stats_num; i++) {
oflib/ofl-messages-print.c:        ofl_structs_port_stats_print(stream, msg->stats[i]);
oflib/ofl-messages-print.c:        if (i < msg->stats_num - 1) { fprintf(stream, ", "); };
oflib/ofl-messages-print.c:    for (i=0; i<msg->stats_num; i++) {
oflib/ofl-messages-print.c:        ofl_structs_queue_stats_print(stream, msg->stats[i]);
oflib/ofl-messages-print.c:        if (i < msg->stats_num - 1) { fprintf(stream, ", "); };
oflib/ofl-messages-print.c:    for (i=0; i<msg->stats_num; i++) {
oflib/ofl-messages-print.c:        ofl_structs_group_stats_print(stream, msg->stats[i]);
oflib/ofl-messages-print.c:        if (i < msg->stats_num - 1) { fprintf(stream, ", "); };
oflib/ofl-messages-print.c:    for (i=0; i<msg->stats_num; i++) {
oflib/ofl-messages-print.c:        ofl_structs_group_desc_stats_print(stream, msg->stats[i], exp);
oflib/ofl-messages-print.c:        if (i < msg->stats_num - 1) { fprintf(stream, ", "); };
oflib/ofl-messages-print.c:    ofl_group_print(stream, msg->experimenter_id);
oflib/ofl-messages-print.c:    if (msg->type == OFPST_EXPERIMENTER) {
oflib/ofl-messages-print.c:    ofl_stats_type_print(stream, msg->type);
oflib/ofl-messages-print.c:    fprintf(stream, "\", flags=\"0x%"PRIx32"\"", msg->flags);
oflib/ofl-messages-print.c:    switch (msg->type) {
oflib/ofl-messages-print.c:    ofl_port_print(stream, msg->port);
oflib/ofl-messages-print.c:    ofl_port_print(stream, msg->port);
oflib/ofl-messages-print.c:    for (i=0; i<msg->queues_num; i++) {
oflib/ofl-messages-print.c:        ofl_structs_queue_print(stream, msg->queues[i]);
oflib/ofl-messages-print.c:        if (i < msg->queues_num - 1) { fprintf(stream, ", "); }
oflib/ofl-messages-print.c:    ofl_message_type_print(stream, msg->type);
oflib/ofl-messages-print.c:    switch (msg->type) {
oflib/ofl-messages-print.c:            if (exp == NULL || exp->msg == NULL || exp->msg->to_string == NULL) {
oflib/ofl-messages-print.c:                char *c = exp->msg->to_string((struct ofl_msg_experimenter *)msg);
oflib/ofl-messages.c:    free(msg->data);
oflib/ofl-messages.c:    switch (msg->type) {
oflib/ofl-messages.c:    switch (msg->type) {
oflib/ofl-messages.c:    switch (msg->type) {
oflib/ofl-messages.c:            if (exp == NULL || exp->msg == NULL || exp->msg->free == NULL) {
oflib/ofl-messages.c:            exp->msg->free((struct ofl_msg_experimenter *)msg);
oflib/ofl-messages.c:        free(msg->data);
oflib/ofl-messages.c:    OFL_UTILS_FREE_ARR_FUN2(msg->actions, msg->actions_num,
oflib/ofl-messages.c:        OFL_UTILS_FREE_ARR_FUN2(msg->buckets, msg->buckets_num,
oflib/ofl-messages.c:        ofl_structs_free_match(msg->match, exp);
oflib/ofl-messages.c:        OFL_UTILS_FREE_ARR_FUN2(msg->instructions, msg->instructions_num,
oflib/ofl-messages.c:        ofl_structs_free_flow_stats(msg->stats, exp);
oflib-exp/ofl-exp.c:    switch (msg->experimenter_id) {
oflib-exp/ofl-exp.c:            OFL_LOG_WARN(LOG_MODULE, "Trying to pack unknown EXPERIMENTER message (%u).", msg->experimenter_id);
oflib-exp/ofl-exp.c:    switch (msg->experimenter_id) {
oflib-exp/ofl-exp.c:            OFL_LOG_WARN(LOG_MODULE, "Trying to free unknown EXPERIMENTER message (%u).", msg->experimenter_id);
oflib-exp/ofl-exp.c:    switch (msg->experimenter_id) {
oflib-exp/ofl-exp.c:            OFL_LOG_WARN(LOG_MODULE, "Trying to convert to string unknown EXPERIMENTER message (%u).", msg->experimenter_id);
oflib-exp/ofl-exp.c:            fprintf(stream, "exp{id=\"0x%"PRIx32"\"}", msg->experimenter_id);
oflib-exp/ofl-exp-openflow.c:    if (msg->experimenter_id == OPENFLOW_VENDOR_ID) {
oflib-exp/ofl-exp-openflow.c:    if (msg->experimenter_id == OPENFLOW_VENDOR_ID) {
oflib-exp/ofl-exp-openflow.c:    if (msg->experimenter_id == OPENFLOW_VENDOR_ID) {
oflib-exp/ofl-exp-openflow.c:        fprintf(stream, "exp{exp_id=\"%u\"}", msg->experimenter_id);
oflib-exp/ofl-exp-nicira.c:    if (msg->experimenter_id == NX_VENDOR_ID) {
oflib-exp/ofl-exp-nicira.c:    if (msg->experimenter_id == NX_VENDOR_ID) {
oflib-exp/ofl-exp-nicira.c:    if (msg->experimenter_id == NX_VENDOR_ID) {
oflib-exp/ofl-exp-nicira.c:        fprintf(stream, "exp{exp_id=\"%u\"}", msg->experimenter_id);
secchan/stp-secchan.c:    oh = msg->data;
secchan/stp-secchan.c:        && msg->size >= offsetof(struct ofp_switch_features, ports)) {
secchan/stp-secchan.c:        /* struct ofp_switch_features *osf = msg->data;
secchan/secchan.c:    struct ofp_header *oh = msg->data;
secchan/secchan.c:        if (msg->size >= offsetof (struct ofp_packet_in, data)) {
secchan/secchan.c:            return msg->data;
secchan/secchan.c:                      msg->size);
secchan/port-watcher.c:    struct ofp_header *oh = msg->data;
secchan/port-watcher.c:        && msg->size >= offsetof(struct ofp_switch_features, ports)) {
secchan/port-watcher.c:        struct ofp_switch_features *osf = msg->data;
secchan/port-watcher.c:        n_ports = ((msg->size - offsetof(struct ofp_switch_features, ports))
secchan/port-watcher.c:               && msg->size >= sizeof(struct ofp_port_status)) {
secchan/port-watcher.c:        struct ofp_port_status *ops = msg->data;
secchan/port-watcher.c:    struct ofp_header *oh = msg->data;
secchan/port-watcher.c:        && msg->size >= sizeof(struct ofp_port_mod)) {
secchan/port-watcher.c:        struct ofp_port_mod *opm = msg->data;
secchan/status.c:    if (msg->size < sizeof(struct nicira_header)) {
secchan/status.c:    request = msg->data;
secchan/status.c:    sr.request.length = msg->size - sizeof *request;
udatapath/flow_table.c:        if ((msg->out_port == OFPP_ANY || flow_entry_has_out_port(entry, msg->out_port)) &&
udatapath/flow_table.c:            (msg->out_group == OFPG_ANY || flow_entry_has_out_group(entry, msg->out_group)) &&
udatapath/flow_table.c:                                (struct ofl_match_standard *)msg->match)) {
udatapath/flow_table.c:        if ((msg->out_port == OFPP_ANY || flow_entry_has_out_port(entry, msg->out_port)) &&
udatapath/flow_table.c:            (msg->out_group == OFPG_ANY || flow_entry_has_out_group(entry, msg->out_group)) &&
udatapath/flow_table.c:                                 (struct ofl_match_standard *)msg->match)) {
udatapath/datapath.c:    dp_set_dp_desc(dp, msg->dp_desc);
udatapath/datapath.c:    switch (msg->role) {
udatapath/datapath.c:            VLOG_WARN_RL(LOG_MODULE, &rl, "Nicira Role request with unknown role (%u).", msg->role);
udatapath/datapath.c:             .role = msg->role};
udatapath/dp_control.c:    flags = msg->config->flags & OFPC_FRAG_MASK;
udatapath/dp_control.c:    dp->config.miss_send_len = msg->config->miss_send_len;
udatapath/dp_control.c:    error = dp_actions_validate(dp, msg->actions_num, msg->actions);
udatapath/dp_control.c:    if (msg->buffer_id == NO_BUFFER) {
udatapath/dp_control.c:        ofpbuf_use(buf, msg->data, msg->data_length);
udatapath/dp_control.c:        ofpbuf_put_uninit(buf, msg->data_length);
udatapath/dp_control.c:        pkt = packet_create(dp, msg->in_port, buf, true);
udatapath/dp_control.c:        pkt = dp_buffers_retrieve(dp->buffers, msg->buffer_id);
udatapath/dp_control.c:    dp_execute_action_list(pkt, msg->actions_num, msg->actions);
udatapath/dp_control.c:    switch (msg->type) {
udatapath/dp_control.c:             .data_length = msg->data_length,
udatapath/dp_control.c:             .data        = msg->data};
udatapath/dp_control.c:    switch (msg->type) {
udatapath/group_table.c:    if (msg->group_id == OFPG_ALL) {
udatapath/group_table.c:        entry = group_table_find(table, msg->group_id);
udatapath/group_table.c:                 .stats_num = msg->group_id == OFPG_ALL ? table->entries_num : 1,
udatapath/group_table.c:                 .stats     = xmalloc(sizeof(struct ofl_group_stats *) * (msg->group_id == OFPG_ALL ? table->entries_num : 1))
udatapath/group_table.c:        if (msg->group_id == OFPG_ALL) {
udatapath/dp_exp.c:	VLOG_WARN_RL(LOG_MODULE, &rl, "Trying to handle unknown experimenter stats (%u).", msg->experimenter_id);
udatapath/dp_exp.c:    switch (msg->experimenter_id) {
udatapath/pipeline.c:    for (i=0; i< msg->instructions_num; i++) {
udatapath/pipeline.c:        if (msg->instructions[i]->type == OFPIT_APPLY_ACTIONS ||
udatapath/pipeline.c:            msg->instructions[i]->type == OFPIT_WRITE_ACTIONS) {
udatapath/pipeline.c:            struct ofl_instruction_actions *ia = (struct ofl_instruction_actions *)msg->instructions[i];
udatapath/pipeline.c:    if (msg->table_id == 0xff) {
udatapath/pipeline.c:        if (msg->command == OFPFC_DELETE || msg->command == OFPFC_DELETE_STRICT) {
udatapath/pipeline.c:        error = flow_table_flow_mod(pl->tables[msg->table_id], msg, &match_kept, &insts_kept);
udatapath/pipeline.c:        if ((msg->command == OFPFC_ADD || msg->command == OFPFC_MODIFY || msg->command == OFPFC_MODIFY_STRICT) &&
udatapath/pipeline.c:                            msg->buffer_id != NO_BUFFER) {
udatapath/pipeline.c:            pkt = dp_buffers_retrieve(pl->dp->buffers, msg->buffer_id);
udatapath/pipeline.c:                VLOG_WARN_RL(LOG_MODULE, &rl, "The buffer flow_mod referred to was empty (%u).", msg->buffer_id);
udatapath/pipeline.c:    if (msg->table_id == 0xff) {
udatapath/pipeline.c:            pl->tables[i]->stats->config = msg->config;
udatapath/pipeline.c:        pl->tables[msg->table_id]->stats->config = msg->config;
udatapath/pipeline.c:    if (msg->table_id == 0xff) {
udatapath/pipeline.c:        flow_table_stats(pl->tables[msg->table_id], msg, &stats, &stats_size, &stats_num);
udatapath/pipeline.c:    if (msg->table_id == 0xff) {
udatapath/pipeline.c:        flow_table_aggregate_stats(pl->tables[msg->table_id], msg,
udatapath/dp_ports.c:    struct sw_port *p = dp_ports_lookup(dp, msg->port_no);
udatapath/dp_ports.c:    if (memcmp(msg->hw_addr, netdev_get_etheraddr(p->netdev),
udatapath/dp_ports.c:    if (msg->mask) {
udatapath/dp_ports.c:        p->conf->config &= ~msg->mask;
udatapath/dp_ports.c:        p->conf->config |= msg->config & msg->mask;
udatapath/dp_ports.c:    if (msg->port_no == OFPP_ANY) {
udatapath/dp_ports.c:        port = dp_ports_lookup(dp, msg->port_no);
udatapath/dp_ports.c:    if (msg->port_no == OFPP_ANY) {
udatapath/dp_ports.c:            if (msg->queue_id == OFPQ_ALL) {
udatapath/dp_ports.c:                if (msg->queue_id < port->max_queues) {
udatapath/dp_ports.c:                    if (port->queues[msg->queue_id].port != NULL) {
udatapath/dp_ports.c:            if (msg->queue_id == OFPQ_ALL) {
udatapath/dp_ports.c:                if (msg->queue_id < port->max_queues) {
udatapath/dp_ports.c:                    if (port->queues[msg->queue_id].port != NULL) {
udatapath/dp_ports.c:                        reply.stats[idx] = port->queues[msg->queue_id].stats;
udatapath/dp_ports.c:        port = dp_ports_lookup(dp, msg->port_no);
udatapath/dp_ports.c:            if (msg->queue_id == OFPQ_ALL) {
udatapath/dp_ports.c:                if (msg->queue_id < port->max_queues) {
udatapath/dp_ports.c:                    if (port->queues[msg->queue_id].port != NULL) {
udatapath/dp_ports.c:                        reply.stats[0] = port->queues[msg->queue_id].stats;
udatapath/dp_ports.c:    p = dp_ports_lookup(dp, msg->port);
udatapath/dp_ports.c:    if (p == NULL || (p->stats->port_no != msg->port)) {
udatapath/dp_ports.c:                 .port       = msg->port,
udatapath/dp_ports.c:    p = dp_ports_lookup(dp, msg->port_id);
udatapath/dp_ports.c:        q = dp_ports_lookup_queue(p, msg->queue->queue_id);
udatapath/dp_ports.c:                                 ((struct ofl_queue_prop_min_rate *)msg->queue->properties[0])->rate);
udatapath/dp_ports.c:                 VLOG_ERR(LOG_MODULE, "Failed to update queue %d", msg->queue->queue_id);
udatapath/dp_ports.c:                         ((struct ofl_queue_prop_min_rate *)msg->queue->properties[0])->rate;
udatapath/dp_ports.c:            error = port_add_queue(p, msg->queue->queue_id,
udatapath/dp_ports.c:                                       (struct ofl_queue_prop_min_rate *)msg->queue->properties[0]);
udatapath/dp_ports.c:            q = dp_ports_lookup_queue(p, msg->queue->queue_id);
udatapath/dp_ports.c:                                ((struct ofl_queue_prop_min_rate *)msg->queue->properties[0])->rate);
udatapath/dp_ports.c:                    VLOG_ERR(LOG_MODULE, "Failed to configure queue %d", msg->queue->queue_id);
udatapath/dp_ports.c:        VLOG_ERR(LOG_MODULE, "Failed to create/modify queue - port %d doesn't exist", msg->port_id);
udatapath/dp_ports.c:    p = dp_ports_lookup(dp, msg->port_id);
udatapath/dp_ports.c:        q = dp_ports_lookup_queue(p, msg->queue->queue_id);
utilities/dpctl.c:            if (parse_port(token + strlen(PORT_MOD_PORT KEY_VAL), &msg->port_no)) {
utilities/dpctl.c:            if (parse_dl_addr(token + strlen(PORT_MOD_HW_ADDR KEY_VAL), msg->hw_addr)) {
utilities/dpctl.c:            if (sscanf(token + strlen(PORT_MOD_HW_CONFIG KEY_VAL), "0x%"SCNx32"", &msg->config) != 1) {
utilities/dpctl.c:            if (sscanf(token + strlen(PORT_MOD_MASK KEY_VAL), "0x%"SCNx32"", &msg->mask) != 1) {
utilities/dpctl.c:            if (sscanf(token + strlen(PORT_MOD_ADVERTISE KEY_VAL), "0x%"SCNx32"", &msg->advertise) != 1) {
utilities/dpctl.c:            if (parse_table(token + strlen(TABLE_MOD_TABLE KEY_VAL), &msg->table_id)) {
utilities/dpctl.c:            if (sscanf(token + strlen(TABLE_MOD_CONFIG KEY_VAL), "0x%"SCNx32"", &msg->config) != 1) {
